// +build ignore

package main

import (
	"log"
	"os"
	"reflect"
	"strings"
	"text/template"
	"go/format"

	"github.com/Fanatics/graphql-ast-helpers/meta"
	metatmpl "github.com/Fanatics/graphql-ast-helpers/internal/template"
)

var tmpl *template.Template

func init() {
	tmpl = template.Must(template.New("").Funcs(metatmpl.MergersFuncs).Parse(tmplstr))
}

func main() {
	mergersDir := os.Args[1]

	for kind, t := range meta.AllKinds() {
		file, err := os.Create(mergersDir + "/mergers_" + strings.ToLower(kind) + "_gen.go")
		if err != nil {
			log.Fatal(1, err)
		}
		defer file.Close()

		out := &strings.Builder{}

		gk := genKind{
			Kind: kind,
			Type: t,
		}

		if err := tmpl.Execute(out, gk); err != nil {
			log.Fatal(1, err)
		}

		bs, err := format.Source([]byte(out.String()))
		if err != nil {
			log.Fatal(1, err)
		}

		if _, err := file.WriteString(string(bs)); err != nil {
			log.Fatal(1, err)
		}
	}
}

type genKind struct {
	Kind string
	Type reflect.Type
}

var tmplstr = `// Code generated by go generate; DO NOT EDIT.
package mergers

import (
	"fmt"
	"github.com/graphql-go/graphql/language/ast"
	"github.com/graphql-go/graphql/language/printer"
	"github.com/richardwilkes/toolbox/errs"
)

var _ = fmt.Sprint
var _ = printer.Print

{{- $type := .Type }}

// Similar{{ .Kind }} merges declarations of {{ .Kind }} that share the same {{ .Kind }} value.
// This uses the default basic merge strategy.
func Similar{{ .Kind }}(curr []{{ $type }}, more ...{{ $type }}) ([]{{ $type }}, error) {
	return Basic.Similar{{ .Kind }}(curr, more...)
}

// One{{ .Kind }} attempts to merge all members of {{ .Kind }} into a singe {{ $type }}.
// If this cannot be done, this method will return an error.
// This uses the default basic merge strategy.
func One{{ .Kind }}(curr []{{ $type }}, more ...{{ $type }}) ({{ $type }}, error) {
	return Basic.One{{ .Kind }}(curr, more...)
}

// Similar{{ .Kind }} merges declarations of {{ .Kind }} that share the same {{ .Kind }} value.
func (m *Merger) Similar{{ .Kind }}(curr []{{ $type }}, more ...{{ $type }}) ([]{{ $type }}, error) {
	if m == nil {
		return nil, errs.New("merger strategy was nil")
	}

	all := append(curr, more...)
	if len(all) <= 1 {
		return all, nil
	}

	groups := make(map[string][]{{ $type }})
	for _, one := range all {
		if key := {{ getKey .Kind "one" }}; key != "" {
			curr, _ := groups[key]
			groups[key] = append(curr, one)
		}
	}

	var out []{{ $type }}
	var errSet error

	for _, group := range groups {
		if merged, err := m.One{{ .Kind }}(group); err != nil {
			errSet = errs.Append(errSet, err)
		} else if merged != nil {
			out = append(out, merged)
		}
	}

	return out, errSet
}

// One{{ .Kind }} attempts to merge all members of {{ .Kind }} into a singe {{ $type }}.
// If this cannot be done, this method will return an error.
func (m *Merger) One{{ .Kind }}(curr []{{ $type }}, more ...{{ $type }}) ({{ $type }}, error) {
	if m == nil {
		return nil, errs.New("merger strategy was nil")
	}

	// escape hatch when no calculation is needed
	all := append(curr, more...)
	if n := len(all); n == 0 {
		return nil, nil
	} else if n == 1 {
		return all[0], nil
	}

	{{- $slices := propsSlices .Kind }}
	{{- if $slices }}
	// prepare property collections
	{{ $slices }}
	{{- end }}

	{{- $pm := propsAppenders .Kind "one" }}
	{{- if $pm }}
	// range over the parent struct and collect properties
	for _, one := range all {
		{{ $pm }}
	}
	{{- end }}

	var errSet error

	// merge properties
	{{ propsMergers .Kind }}
}
`
